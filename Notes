It's essential you have visibility of the performance of your DB and queries.

Laravel Debug Bar
-----------------
- composer require barryvdh/laravel-debugbar --dev

- Check page load time towards the right of the debug bar. You should aim for less then 1000ms.
- Look at the number of queries. Can it be reduced by n+1 etc?
- Do you need indexing on any queries using orderBy?
- Look at the Models tabs to see how many models are being loaded. An unexpectedly high number might
give you an idea of why it is slow.
- The Memory Usage tab can give you a rough insite into what is going on. Laravel uses roughly 4mb of
memory by itself. Anything significantly over this should be a warning sign.

- Eager loading models can sound like a good idea but can actually lead to large numbers of models being loaded
when you might only need the last one. You can use caching but this can add more complexity into your
application. e.g. you could add a foreign key call last_login_id on the users table. This is a form of caching.
- A sub-query could be the solution. It is important to know that DBs are optimised for running this kind of query
whereas Laravel and PHP are not optimised to sort through result sets in the same way. So try and user the query language
to extract only the data you need.

- If  you run EXPLAIN on the query generated by the search query AFTER adding the indexes to the users and companies
table, you will see that there are no possible_keys and key values. MYSQL is no able to use an index in a query
if the query has the % wildcard symbols. Sometimes you just have to experiment with the queries in your sql client
to see how you can get the query to work with indexes.


Checklist
----------
- Are you using the $with attribute anywhere?
- Do you need indexing?
- Are you selecting only the columns you need?
- are you using dynamic queries instead of eager loading all models?
- Are you repeating queries when you can use the whereRaw thing as per commit?
- Can you use setRelationship to avoid circular relationships.
- Can you use subqueries instead of whereHas to get sql to use indexes?
