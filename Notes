It's essential you have visibility of the performance of your DB and queries.
* Seeders for all content is available in course content.

Laravel Debug Bar
-----------------
- composer require barryvdh/laravel-debugbar --dev

- Check page load time towards the right of the debug bar. You should aim for less then 1000ms.
- Look at the number of queries. Can it be reduced by n+1 etc?
- Do you need indexing on any queries using orderBy?
- Look at the Models tabs to see how many models are being loaded. An unexpectedly high number might
give you an idea of why it is slow.
- The Memory Usage tab can give you a rough insight into what is going on. Laravel uses roughly 4mb of
memory by itself. Anything significantly over this should be a warning sign.

- Eager loading models can sound like a good idea but can actually lead to large numbers of models being loaded
when you might only need the last one. You can use caching but this can add more complexity into your
application. e.g. you could add a foreign key call last_login_id on the users table. This is a form of caching.
- A sub-query could be the solution. It is important to know that DBs are optimised for running this kind of query
whereas Laravel and PHP are not optimised to sort through result sets in the same way. So try and user the query language
to extract only the data you need.

- If  you run EXPLAIN on the query generated by the search query AFTER adding the indexes to the users and companies
table, you will see that there are no possible_keys and key values. MYSQL is no able to use an index in a query
if the query has the % wildcard symbols. Sometimes you just have to experiment with the queries in your sql client
to see how you can get the query to work with indexes.

- Sometimes it is not possible to get an index to work on all parts of a query (top-level query and subqueries). Sometimes
it may end up being more performant to run a query as separate queries. Try experimenting with EXPLAIN (to see what
has been indexed) and laravel debugbar (to see query performance).

- UNIONS are a way of running multiple queries in isolation within the same query. You can use the above technique
but enjoy the benefits of only running one query. We can simply add the UNION command in-between the queries. The queries
must have the same columns selected. Check the select_type column in EXPLAIN. If you have DEPENDENT SUBQUERY or DEPENDENT
UNION this will mean that the indexed columns are not having their indexes used during the query. To avoid this we
can use a 'derived table'. All you have to do is add an alias to the outside of the subquery.

- The default ordering mechanisms of the DB (i.e. alphabetic, numeric etc) may not be enough to meet your requirements. When
 this happens we can use Custom Algorithms. IT is also possible to add an index on a custom algorithm.

Performant Laravel
-------------------

- Pagination without ordering is a bad idea because DBs won't always return the results in the same order.
- Handle policy filters at the DB level, not by filtering in the template.
- Using multiple fields in the order by clause will mean that normal indexing will not work. The solution to
this is a compound index.

- We can use regexp to normalize searchable terms.

- When ordering by a rel model, i.e. with a hasOne rel, use joins, not subqueries.

- When ordering by belongsTo use a join.

- When ordering by a hasMany, use a subquery

- Natural sorting can be used for sorting numbers. However DBs do not support natural sorting natively.
We can create DB functions in the DB to add our own natural sorting functionality to the DB. * It is possible
to create an index using a custom function in some SQL DBs including Postgres 4, but not currently in MYSQL

- We can add fulltext indexing to migrations e.g. Google fulltext searching using against in boolean mode.

- For details on how to add geometric shape to map see course content.

- For complete geospatial code see course content.

Checklist
----------
- Are you using the $with attribute anywhere?
- Do you need indexing?
- Are you selecting only the columns you need?
- are you using dynamic queries instead of eager loading all models?
- Are you repeating queries when you can use the whereRaw thing as per commit?
- Can you use setRelationship to avoid circular relationships.
- Can you use subqueries instead of whereHas to get sql to use indexes?
- Can you use UNIONS and derived tables to optimise separate but related queries.
- Could you use regexp to normalize searchable fields?
- Are you using orderBy on your pagination?
- Are you using joins for you hasMany and BelongsTo rels
- are you using subqueries for ordering by a hasMany rel?
- are you indexing your custom algorithms?
- can you use denormalisation where indexing can't be used?
